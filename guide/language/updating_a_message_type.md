# 更新消息类型

> 注：内容翻译自官网文档 Language Guide (proto3) 中的 [Updating A Message Type](https://developers.google.com/protocol-buffers/docs/proto3#updating) 一节

如果一个已有的消息类型不再满足需要- 例如, 想增加额外的字段 - 但是依然希望原有格式创建的代码可以继续使用, 不用担心. 可以很简单的更新消息类型而不用打破现有的代码.仅仅需要记住下面的规则:

- 不要改动任何现有字段的数字标签
- 如果添加新的字段时, 使用"老"消息格式系列化后的任何消息都可以被新生成的代码解析. 你需要留意这些元素的默认值以便新的代码可以正确和老代码生成的消息交互. 类似的, 新代码创建的消息可以被老代码解析: 解析时新的字段被简单的忽略. 注意当消息反序列化时未知字段会失效, 因此如果消息被传递给新代码, 新的字段将不再存在(这个行为和proto2不同, 在proto2中未知字段会和消息一起序列化).
- 字段可以被删除, 但是要求在更新后的消息类型中原来的标签数字不再使用.可以考虑重命名这个字段, 或者添加前缀`OBSOLETE_`, 或者保留标签, 以便你的.proto文件未来的用户不会不小心重用这个数字.
- int32, uint32, int64, uint64, 和 bool 是完全兼容的 – 这意味着可以将一个字段的类型从这些类型中的一个修改为另外一个而不会打破向前或者向后兼容.如果一个数字解析时不匹配相应的类型, 那么效果会和在c++里面做类型转换一样(例如64位数字被作为32位整型读取, 将被转换为32位).
- sint32 和 sint64 是彼此兼容的,但是和其他整型类型不兼容.
- string 和 bytes 是兼容的, 如果bytes是有效的UTF-8.
- 嵌入式的消息和bytes兼容, 如果bytes包含这个消息的编码后的内容.
- fixed32 兼容 sfixed32, 而 fixed64 兼容 sfixed64.